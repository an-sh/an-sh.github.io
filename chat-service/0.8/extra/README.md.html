<!DOCTYPE html>
<html>
  <head>
  <meta charset='UTF-8'>
  <title>Chat service Documentation</title>
  <script src='../javascript/application.js'></script>
  <script src='../javascript/search.js'></script>
  <link rel='stylesheet' href='../stylesheets/application.css' type='text/css'>
</head>
  <body>
    <div id='base' data-path='../'></div>
<div id='header'>
  <div id='menu'>
    <a href='../extra/README.md.html' title='Chat service'>
      Chat service
    </a>
    &raquo;
    <a href='../alphabetical_index.html' title='Index'>
      Index
    </a>
    &raquo;
    <span class='title'>README.md</span>
  </div>
</div>
    <div id='content'>
      <nav class='toc'>
        <p class='title'>
          <a class='hide_toc' href='#'>
            <strong>Table of Contents</strong>
          </a>
          <small>
            (<a class='float_toc' href='#'>left</a>)
          </small>
        </p>
      </nav>
      <div id='filecontents'>
        <h1 id="chat-service">Chat service</h1><p><a href="https://badge.fury.io/js/chat-service"><img src="https://badge.fury.io/js/chat-service.svg" alt="NPM Version"></a>
<a href="https://travis-ci.org/an-sh/chat-service"><img src="https://travis-ci.org/an-sh/chat-service.svg?branch=master" alt="Build Status"></a>
<a href="https://ci.appveyor.com/project/an-sh/chat-service"><img src="https://ci.appveyor.com/api/projects/status/qy7v2maica2urkss?svg=true" alt="Appveyor status"></a>
<a href="https://coveralls.io/github/an-sh/chat-service?branch=master"><img src="https://coveralls.io/repos/an-sh/chat-service/badge.svg?branch=master&amp;service=github" alt="Coverage Status"></a>
<a href="https://david-dm.org/an-sh/chat-service"><img src="https://david-dm.org/an-sh/chat-service.svg" alt="Dependency Status"></a></p><p>Messaging service designed to handle a vast variety of use cases that
are fit into a chat-like pattern, including exchanging data in
collaborative applications, logging with realtime updates, or a full
protocol/API tunnelling for IoT devices.</p><h3 id="features">Features</h3>
<ul>
<li><p>Reliable room messaging using a server side history storage and a
synchronisation API.</p></li>
<li><p>Customisable JSON messages format via just a validation function
(hook), allowing custom or heterogeneous room messages format
(including support of a binary data inside JSON).</p></li>
<li><p>Per-room user presence API and notifications.</p></li>
<li><p>Room creation and room permissions management APIs (with changes
notifications). Supports for blacklist or whitelist based access
modes and a room administrators management.</p></li>
<li><p>Lightweight online user to online user messages with a server side
permissions management API.</p></li>
<li><p>Seamless support of multiple socket connections for a single user,
including a reasonable amount of user&#39;s action notifications from
other sockets.</p></li>
<li><p>Written as a stateless microservice, using Redis as a state store,
can be easily scaled across many machines. Also supports Redis in
cluster configurations as a store.</p></li>
<li><p>Extensive customisation support. Custom functionality can be added
via hooks before/after any client message (command). And client
messages (commands) handlers can be invoked server side as simple
functions.</p></li>
<li><p>Simple networking, only a socket.io client implementation is
required, making it possible to use the same server for web (SPA),
mobile and desktop clients.</p></li>
</ul>
<h3 id="tutorial">Tutorial</h3><p>On a server, define a socket connection hook, as the service is
relying on an extern auth implementation. A user just needs to pass an
auth check, no explicit user adding step is required.</p><pre><code class="lang-javascript">function onConnect(service, id) {
  // Get socket object using id.
  let socket = service.nsp.connected[id]
  // Assuming that auth data is passed in a query string.
  let query = socket.handshake.query
  // Check query data.
  // ...
  // Return a promise that resolves with a login string.
  return Promise.resolve(userName)
}
</code></pre><p>Creating a server is a simple object instantiation. <strong>Note:</strong> that a
<code>close</code> method must be called to correctly shutdown a service (if
redis state is used). To fix an incorrect instance shutdown use
<code>instanceRecovery</code> method.</p><pre><code class="lang-javascript">const port = 8000
const ChatService = require(&#39;chat-service&#39;)
const chatService = new ChatService({port}, {onConnect})
process.on(&#39;SIGINT&#39;, chatService.close().finally(() =&gt; process.exit()))
</code></pre><p>Server is now running on port <code>8000</code>, using memory state. By default
<code>&#39;/chat-service&#39;</code> socket.io namespace is used. Adding a room with
<code>admin</code> user as an owner.</p><pre><code class="lang-javascript">chatService.addRoom(&#39;default&#39;, { owner: &#39;admin&#39; })
</code></pre><p>On a client just a <code>socket.io-client</code> implementation is required. To
send a command use <code>emit</code> method, the result (or an error) will be
returned in socket.io ack callback. To listen to server messages use
<code>on</code> method.</p><pre><code class="lang-javascript">let io = require(&#39;socket.io-client&#39;)
let url = &#39;localhost:8000/chat-service&#39;
let user = &#39;someLogin&#39;
let password = &#39;somePassword&#39;
let query = `user=${user}&amp;password=${password}`
let params = { query }
// Connect to server.
let socket = io.connect(url, params)
socket.once(&#39;loginConfirmed&#39;, (userName) =&gt; {
  // Auth success.
  socket.on(&#39;roomMessage&#39;, (room, msg) =&gt; {
    // Room message handler.
  })
  // Join room &#39;default&#39;.
  socket.emit(&#39;roomJoin&#39;, &#39;default&#39;, (error, data) =&gt; {
    // Check for a command error.
    if (error) return
    // Now we will receive &#39;default&#39; room messages in &#39;roomMessage&#39; handler.
    // Now we can also send a message to &#39;default&#39; room:
    socket.emit(&#39;roomMessage&#39;, &#39;default&#39;, { textMessage: &#39;Hello!&#39; })
  })
})
socket.once(&#39;loginRejected&#39;, (error) =&gt; {
  // Auth error handler.
})
</code></pre><p>Look in the API documentation for details about custom message
formats, rooms management, rooms permission and users presence.</p><h3 id="api-documentation">API documentation</h3><p>Is available online at
<a href="https://an-sh.github.io/chat-service/0.8/">gitpages</a>.</p><ul>
<li><p><code>ServerMessages</code> class describes socket.io messages that are sent
from the server to a client.</p></li>
<li><p><code>UserCommands</code> class describes socket.io messages that a client
sends to a server and receives reply as a socket.io ack.</p></li>
<li><p><code>ChatService</code> class is the package exported object and a service
instance constructor, describes options. It also contains mixin
methods for using server side API.</p></li>
</ul><p>Run <code>npm install -g codo</code> and <code>codo</code> to generate local documentation.</p><h3 id="frontend-example">Frontend example</h3><p>An Angular single page chat application with a basic features
demonstration is now in a separate
<a href="https://github.com/an-sh/chat-service-frontend-angular1">repo</a>. You
can also run this example as a cluster with several node
processes. Check <code>README.md</code> file in that repository for more
information.</p><h3 id="bug-reporting-and-debugging">Bug reporting and debugging</h3><p>In normal circumstances all errors that are returned to a service user
(via commands ack, or <code>loginConfirmed</code>/<code>loginRejected</code> messages)
should be instances of <code>ChatServiceError</code>. All other errors mean a
bug, or some failures in the service infrastructure. To enable debug
logging of such errors use <code>export NODE_DEBUG=ChatService</code>. The
library is using bluebird <code>^3.0.0</code> promises implementation, so to
enable long stack traces use <code>export BLUEBIRD_DEBUG=1</code>. It is highly
recommended to follow this conventions for extension hooks
development.</p><p>If you encounter a bug in this package, please submit a bug report at
github repo <a href="https://github.com/an-sh/chat-service/issues">issues</a>.</p><h3 id="license">License</h3><p>MIT</p>
      </div>
    </div>
    <div id='footer'>
  By
  <a href='https://github.com/coffeedoc/codo' title='CoffeeScript API documentation generator'>
    Codo
  </a>
  2.1.0
  &#10034;
  Press H to see the keyboard shortcuts
  &#10034;
  <a href='http://twitter.com/netzpirat' target='_parent'>@netzpirat</a>
  &#10034;
  <a href='http://twitter.com/_inossidabile' target='_parent'>@_inossidabile</a>
</div>
<iframe id='search_frame'></iframe>
<div id='fuzzySearch'>
  <input type='text'>
  <ol></ol>
</div>
<div id='help'>
  <p>
    Quickly fuzzy find classes, mixins, methods, file:
  </p>
  <ul>
    <li>
      <span>T</span>
      Open fuzzy finder dialog
    </li>
  </ul>
  <p>
    Control the navigation frame:
  </p>
  <ul>
    <li>
      <span>L</span>
      Toggle list view
    </li>
    <li>
      <span>C</span>
      Show class list
    </li>
    <li>
      <span>I</span>
      Show mixin list
    </li>
    <li>
      <span>F</span>
      Show file list
    </li>
    <li>
      <span>M</span>
      Show method list
    </li>
    <li>
      <span>E</span>
      Show extras list
    </li>
  </ul>
  <p>
    You can focus and blur the search input:
  </p>
  <ul>
    <li>
      <span>S</span>
      Focus search input
    </li>
    <li>
      <span>Esc</span>
      Blur search input
    </li>
  </ul>
</div>
  </body>
</html>