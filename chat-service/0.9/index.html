<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="chat-service.ChatService.html">ChatService</a><ul class='members'><li data-type='member'><a href="chat-service.ChatService.html#.ChatServiceError">ChatServiceError</a></li><li data-type='member'><a href="chat-service.ChatService.html#.SocketIOClusterBus">SocketIOClusterBus</a></li><li data-type='member'><a href="chat-service.ChatService.html#clusterBus">clusterBus</a></li><li data-type='member'><a href="chat-service.ChatService.html#instanceUID">instanceUID</a></li><li data-type='member'><a href="chat-service.ChatService.html#transport">transport</a></li></ul><ul class='methods'><li data-type='method'><a href="chat-service.ChatService.html#checkArguments">checkArguments</a></li><li data-type='method'><a href="chat-service.ChatService.html#close">close</a></li></ul></li><li><a href="chat-service.TransportPlugin.html">TransportPlugin</a><ul class='methods'><li data-type='method'><a href="chat-service.TransportPlugin.html#close">close</a></li><li data-type='method'><a href="chat-service.TransportPlugin.html#disconnectSocket">disconnectSocket</a></li><li data-type='method'><a href="chat-service.TransportPlugin.html#joinChannel">joinChannel</a></li><li data-type='method'><a href="chat-service.TransportPlugin.html#leaveChannel">leaveChannel</a></li><li data-type='method'><a href="chat-service.TransportPlugin.html#setEvents">setEvents</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="chat-service.ChatService.html#.event:closed">closed</a></li><li><a href="chat-service.ChatService.html#.event:lockTimeExceeded">lockTimeExceeded</a></li><li><a href="chat-service.ChatService.html#.event:ready">ready</a></li><li><a href="chat-service.ChatService.html#.event:storeConsistencyFailure">storeConsistencyFailure</a></li><li><a href="chat-service.ChatService.html#.event:transportConsistencyFailure">transportConsistencyFailure</a></li></ul><h3>Namespaces</h3><ul><li><a href="chat-service.html">chat-service</a></li><li><a href="chat-service.config.html">config</a></li><li><a href="chat-service.hooks.html">hooks</a></li><li><a href="rpc.html">rpc</a></li><li><a href="rpc.clientRequests.html">clientRequests</a><ul class='methods'><li data-type='method'><a href="rpc.clientRequests.html#.directAddToList">directAddToList</a></li><li data-type='method'><a href="rpc.clientRequests.html#.directGetAccessList">directGetAccessList</a></li><li data-type='method'><a href="rpc.clientRequests.html#.directGetWhitelistMode">directGetWhitelistMode</a></li><li data-type='method'><a href="rpc.clientRequests.html#.directMessage">directMessage</a></li><li data-type='method'><a href="rpc.clientRequests.html#.directRemoveFromList">directRemoveFromList</a></li><li data-type='method'><a href="rpc.clientRequests.html#.directSetWhitelistMode">directSetWhitelistMode</a></li><li data-type='method'><a href="rpc.clientRequests.html#.listOwnSockets">listOwnSockets</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomAddToList">roomAddToList</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomCreate">roomCreate</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomDelete">roomDelete</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomGetAccessList">roomGetAccessList</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomGetOwner">roomGetOwner</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomGetWhitelistMode">roomGetWhitelistMode</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomHistoryGet">roomHistoryGet</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomHistoryInfo">roomHistoryInfo</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomJoin">roomJoin</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomLeave">roomLeave</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomMessage">roomMessage</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomNotificationsInfo">roomNotificationsInfo</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomRecentHistory">roomRecentHistory</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomRemoveFromList">roomRemoveFromList</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomSetWhitelistMode">roomSetWhitelistMode</a></li><li data-type='method'><a href="rpc.clientRequests.html#.roomUserSeen">roomUserSeen</a></li><li data-type='method'><a href="rpc.clientRequests.html#.systemMessage">systemMessage</a></li></ul></li><li><a href="rpc.datatypes.html">datatypes</a><ul class='members'><li data-type='member'><a href="rpc.datatypes.html#.codeToFormat">codeToFormat</a></li></ul></li><li><a href="rpc.serverNotifications.html">serverNotifications</a><ul class='methods'><li data-type='method'><a href="rpc.serverNotifications.html#.directMessage">directMessage</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.directMessageEcho">directMessageEcho</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.loginConfirmed">loginConfirmed</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.loginRejected">loginRejected</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomAccessListAdded">roomAccessListAdded</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomAccessListRemoved">roomAccessListRemoved</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomAccessRemoved">roomAccessRemoved</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomJoinedEcho">roomJoinedEcho</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomLeftEcho">roomLeftEcho</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomMessage">roomMessage</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomModeChanged">roomModeChanged</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomUserJoined">roomUserJoined</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.roomUserLeft">roomUserLeft</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.socketConnectEcho">socketConnectEcho</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.socketDisconnectEcho">socketDisconnectEcho</a></li><li data-type='method'><a href="rpc.serverNotifications.html#.systemMessage">systemMessage</a></li></ul></li></ul><h3>Mixins</h3><ul><li><a href="chat-service.RecoveryAPI.html">RecoveryAPI</a><ul class='methods'><li data-type='method'><a href="chat-service.RecoveryAPI.html#getInstanceHeartbeat">getInstanceHeartbeat</a></li><li data-type='method'><a href="chat-service.RecoveryAPI.html#instanceRecovery">instanceRecovery</a></li><li data-type='method'><a href="chat-service.RecoveryAPI.html#roomStateSync">roomStateSync</a></li><li data-type='method'><a href="chat-service.RecoveryAPI.html#userStateSync">userStateSync</a></li></ul></li><li><a href="chat-service.ServiceAPI.html">ServiceAPI</a><ul class='methods'><li data-type='method'><a href="chat-service.ServiceAPI.html#addRoom">addRoom</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#addUser">addUser</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#changeAccessListsUpdates">changeAccessListsUpdates</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#changeRoomHistoryMaxSize">changeRoomHistoryMaxSize</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#changeRoomOwner">changeRoomOwner</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#changeUserlistUpdates">changeUserlistUpdates</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#deleteRoom">deleteRoom</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#deleteUser">deleteUser</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#disconnectUserSockets">disconnectUserSockets</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#execUserCommand">execUserCommand</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#hasDirectAccess">hasDirectAccess</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#hasRoom">hasRoom</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#hasRoomAccess">hasRoomAccess</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#hasUser">hasUser</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#roomHasInList">roomHasInList</a></li><li data-type='method'><a href="chat-service.ServiceAPI.html#userHasInList">userHasInList</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="chat-service.ExecInfo.html">ExecInfo</a></li><li><a href="chat-service.hooks.CommandsHooks.html">CommandsHooks</a></li><li><a href="chat-service.hooks.HooksInterface.html">HooksInterface</a><ul class='methods'><li data-type='method'><a href="chat-service.hooks.HooksInterface.html#.directMessagesChecker">directMessagesChecker</a></li><li data-type='method'><a href="chat-service.hooks.HooksInterface.html#.onClose">onClose</a></li><li data-type='method'><a href="chat-service.hooks.HooksInterface.html#.onConnect">onConnect</a></li><li data-type='method'><a href="chat-service.hooks.HooksInterface.html#.onDisconnect">onDisconnect</a></li><li data-type='method'><a href="chat-service.hooks.HooksInterface.html#.onStart">onStart</a></li><li data-type='method'><a href="chat-service.hooks.HooksInterface.html#.roomMessagesChecker">roomMessagesChecker</a></li></ul></li><li><a href="chat-service.TransportInterface.html">TransportInterface</a><ul class='methods'><li data-type='method'><a href="chat-service.TransportInterface.html#bindHandler">bindHandler</a></li><li data-type='method'><a href="chat-service.TransportInterface.html#emitToChannel">emitToChannel</a></li><li data-type='method'><a href="chat-service.TransportInterface.html#getHandshakeData">getHandshakeData</a></li><li data-type='method'><a href="chat-service.TransportInterface.html#getServer">getServer</a></li><li data-type='method'><a href="chat-service.TransportInterface.html#getSocket">getSocket</a></li><li data-type='method'><a href="chat-service.TransportInterface.html#sendToChannel">sendToChannel</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><h1>Chat Service</h1><p><a href="https://badge.fury.io/js/chat-service"><img src="https://badge.fury.io/js/chat-service.svg" alt="NPM Version"></a>
<a href="https://travis-ci.org/an-sh/chat-service"><img src="https://travis-ci.org/an-sh/chat-service.svg?branch=master" alt="Build Status"></a>
<a href="https://ci.appveyor.com/project/an-sh/chat-service"><img src="https://ci.appveyor.com/api/projects/status/qy7v2maica2urkss?svg=true" alt="Appveyor status"></a>
<a href="https://codecov.io/gh/an-sh/chat-service"><img src="https://codecov.io/gh/an-sh/chat-service/branch/master/graph/badge.svg" alt="Coverage Status"></a>
<a href="https://david-dm.org/an-sh/chat-service"><img src="https://david-dm.org/an-sh/chat-service.svg" alt="Dependency Status"></a>
<a href="http://standardjs.com/"><img src="https://img.shields.io/badge/code%20style-standard-brightgreen.svg" alt="JavaScript Style Guide"></a></p>
<p>Room messaging server implementation that is using a bidirectional RPC
protocol to implement chat-like communication. Designed to handle
common public network messaging problems like reliable delivery,
multiple connections from a single user, real-time permissions and
presence. RPC requests processing and a room messages format are
customisable via hooks, allowing to implement anything from a
chat-rooms server to a collaborative application with a complex
conflict resolution. Room messages also can be used to create public
APIs or to tunnel M2M communications for IoT devices.</p>
<h2>Features</h2><ul>
<li><p>Reliable room messaging using a server side history storage and a
synchronisation API.</p>
</li>
<li><p>Arbitrary messages format via just a validation function (hook),
allowing custom/heterogeneous messages formats (including a binary
data inside messages).</p>
</li>
<li><p>Per-room user presence API with notifications.</p>
</li>
<li><p>Realtime room creation and per-room users permissions management
APIs. Supports for blacklist or whitelist based access modes and an
optional administrators group.</p>
</li>
<li><p>Seamless support of multiple users' connections from various devises
to any service instance.</p>
</li>
<li><p>Written as a stateless microservice, uses Redis (also supports
cluster configurations) as a state store, can be horizontally scaled
on demand.</p>
</li>
<li><p>Extensive customisation support. Custom functionality can be added
via hooks before/after for any client request processing. And
requests (commands) handlers can be invoked server side via an API.</p>
</li>
<li><p>Pluginable networking transport. Client-server communication is done
via a bidirectional RPC protocol. Socket.io transport implementation
is included.</p>
</li>
<li><p>Supports lightweight online user to online user messaging.</p>
</li>
<li><p>Now fully rewritten in <strong>ES6</strong>, runs natively on Node.js <code>&gt;= 6</code> (ES5
Babel transpired code is included for Node.js <code>4.x</code> and <code>0.12</code>
compatibility).</p>
</li>
</ul>
<h2>Quickstart with socket.io</h2><p>On a server-side define a socket connection hook, as the service is
relying on an extern auth implementation. A user just needs to pass an
auth check, no explicit user adding step is required.</p>
<pre class="prettyprint source lang-javascript"><code>function onConnect (service, id) {
  // Assuming that auth data is passed in a query string.
  let { query } = service.transport.getHandshakeData(id)
  let { userName } = query
  // Actually check auth data.
  // ...
  // Return a promise that resolves with a login string.
  return Promise.resolve(userName)
}</code></pre><p>Creating a server is a simple object instantiation. Note: <code>close</code>
method <em>must</em> be called to correctly shutdown a service instance (see
<a href="#failures-recovery">Failures recovery</a>).</p>
<pre class="prettyprint source lang-javascript"><code>const port = 8000
const ChatService = require('chat-service')
const chatService = new ChatService({port}, {onConnect})
process.on('SIGINT', () => chatService.close().finally(() => process.exit()))</code></pre><p>Server is now running on port <code>8000</code>, using memory state. By default
<code>'/chat-service'</code> socket.io namespace is used. Add a room with <code>admin</code>
user as the room owner. All rooms must be explicitly created (option
to allow rooms creation from a client side is also provided).</p>
<pre class="prettyprint source lang-javascript"><code>chatService.addRoom('default', { owner: 'admin' })</code></pre><p>On a client just a <code>socket.io-client</code> implementation is required. To
send a request (command) use <code>emit</code> method, the result (or an error)
will be returned in socket.io ack callback. To listen to server
messages use <code>on</code> method.</p>
<pre class="prettyprint source lang-javascript"><code>let io = require('socket.io-client')
let url = 'ws://localhost:8000/chat-service'
let userName = 'user'
let token = 'token' // auth token
let query = `userName=${userName}&token=${token}`
let params = { query }
// Connect to server.
let socket = io.connect(url, params)
socket.once('loginConfirmed', userName => {
  // Auth success.
  socket.on('roomMessage', (room, msg) => {
    // Rooms messages handler (own messages are here too).
    console.log(`${msg.author}: ${msg.textMessage}`)
  })
  // Join room 'default'.
  socket.emit('roomJoin', 'default', (error, data) => {
    // Check for a command error.
    if (error) return
    // Now we will receive 'default' room messages in 'roomMessage' handler.
    // Now we can also send a message to 'default' room:
    socket.emit('roomMessage', 'default', { textMessage: 'Hello!' })
  })
})
socket.once('loginRejected', error => {
  // Auth error handler.
  console.error(error)
})</code></pre><p>It is a runnable code, files are in <code>example</code> directory. For more
details and advanced usage see <a href="#documentation">Documentation</a>.</p>
<h2>Concepts overview</h2><h3>User multiple connections</h3><p>Service completely abstracts a connection concept from a user concept,
so a single user can have more than one connection (including
connections across different nodes). For user presence the number of
joined sockets must be just greater than zero. All APIs designed to
work on the user level, handling seamlessly user's multiple
connections.</p>
<p>Connections are completely independent, no additional client side
support is required. But there are info messages and commands that can
be used to get information about other user's connections. It makes
possible to realise client-side sync patterns, like keeping all
connections to be joined to the same rooms.</p>
<h3>Room permissions</h3><p>Each room has a permissions system. There is a single owner user, that
has all administrator privileges and can assign users to the
administrators group. Administrators can manage other users' access
permissions. Two modes are supported: blacklist and whitelist. After
access lists/mode modifications, service automatically removes users
that have lost an access permission.</p>
<p>If <code>enableRoomsManagement</code> options is enabled users can create rooms
via <code>roomCreate</code> command. The creator of a room will be it's owner and
can also delete it via <code>roomDelete</code> command.</p>
<p>Before hooks can be used to implement additional permissions systems.</p>
<h3>Reliable messaging and history synchronisation</h3><p>When a user sends a room message, in RPC reply the message <code>id</code> is
returned. It means that the message has been saved in a store (in an
append only circular buffer like structure). Room message ids are a
sequence starting from <code>1</code>, that increases by one for each
successfully sent message in the room. A client can always check the
last room message id via <code>roomHistoryInfo</code> command, and use
<code>roomHistoryGet</code> command to get missing messages. Such approach
ensures that a message can be received, unless it is deleted due to
rotation.</p>
<h3>Custom messages format</h3><p>By default a client can send messages that are limited to just a
<code>{textMessage: 'Some string'}</code>. To enable custom messages format
provide <code>directMessagesChecker</code> or <code>roomMessagesChecker</code> hooks. When a
hook resolves, a message format is accepted. Messages can be arbitrary
data with a few restrictions. The top level must be an <code>Object</code>,
without <code>timestamp</code>, <code>author</code> or <code>id</code> fields (service will fill this
fields before sending messages). The nested levels can include
arbitrary data types (even binary), but no nested objects with a field
<code>type</code> set to <code>'Buffer'</code> (used for binary data manipulations).</p>
<h3>Integration and customisations</h3><p>Each user command supports before and after hook adding, and a client
connection/disconnection hooks are supported too. Command and hooks
are executed sequentially: before hook - command - after hook (it will
be called on command errors too). Sequence termination in before hooks
is possible. Clients can send additional command arguments, hooks can
read them, and reply with additional arguments.</p>
<p>To execute an user command server side <code>execUserCommand</code> is
provided. Also there are some more server side only methods provided
by <code>ServiceAPI</code> and <code>TransportInterface</code>. Look for some customisation
cases in <a href="#customisation-examples">Customisation examples</a>.</p>
<h3>Failures recovery</h3><p>Service keeps user presence and connection data in a store, that may
be persistent or shared. So if an instance is shutdown incorrectly
(without calling or waiting for <code>close</code> method to finish) or lost
completely network connection to a store, presence data will become
incorrect. To fix this case <code>instanceRecovery</code> method is provided.</p>
<p>Also there are more subtle cases regarding connection-dependant data
consistency. Transport communication instances and store instances can
experience various kind of network, software or hardware failures. In
some edge cases (like operation on multiple users) such failures can
cause inconsistencies (for the most part errors will be returned to
the command's issuers). Such events are reported via instance events
(like <code>storeConsistencyFailure</code>), and data can be sync via
<code>RecoveryAPI</code> methods.</p>
<h2>Customisation examples</h2><h3>Anonymous listeners</h3><p>By default every user is assumed to have an unique login
(userName). Instead of managing names generation, an integration with
a separate transport can be used (or a multiplexed connection, for
example an another socket.io namespace). Room messages can be
forwarded from <code>roomMessage</code> after hook to a transport, that is
accessible without a login. And vice versa some service commands can
be executed by anonymous users via <code>execUserCommand</code> with bypassing
permissions option turned on.</p>
<h3>Explicit multi-device announcements</h3><p>By default there is no way for other users to know the number and
types of user connections joined to a room. Such information can be
passed, for example in a query string and then saved via a connection
hook. The announcement can be made in <code>roomJoin</code> after hook, using
directly transport <code>sendToChannel</code> method. Also additional information
regarding joined devices types should be sent from <code>roomGetAccessList</code>
after hook (when list name is equal to <code>'userlist'</code>).</p>
<h2>Documentation</h2><p>Server-side and RPC APIs documentation is available
<a href="https://an-sh.github.io/chat-service/0.9/">online</a>.</p>
<h2>Debugging</h2><p>Under normal circumstances all errors that are returned to a service
user (via request replies, <code>loginConfirmed</code> or <code>loginRejected</code>
messages) should be instances of <code>ChatServiceError</code>. All other errors
indicate a bug or a failure in a service infrastructure. To enable
debug logging of such errors use <code>export NODE_DEBUG=ChatService</code>. The
library is using bluebird <code>^3.0.0</code> promises implementation, so to
enable long stack traces use <code>export BLUEBIRD_DEBUG=1</code>. It is highly
recommended to follow this conventions for hooks development.</p>
<h2>Bug reporting</h2><p>If you encounter a bug in this package, please submit a bug report at
github repo <a href="https://github.com/an-sh/chat-service/issues">issues</a>.</p>
<h2>License</h2><p>MIT</p></article>
    </section>






</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Aug 05 2016 16:26:03 GMT+0300 (MSK) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>